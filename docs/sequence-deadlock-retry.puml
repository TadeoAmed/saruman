@startuml Deadlock Retry Logic

actor Client
participant UseCase
participant Service
participant Database
participant Logger

Client ->> UseCase: ReserveItems(orderID, companyID, items)

Note over UseCase: reserveItemsWithRetry(maxAttempts=3)

loop attempt = 1 to 3
    Note over UseCase: Attempt #attempt
    UseCase ->> Service: ReserveItems(...)

    alt MySQL Deadlock (error 1213 or 1205)
        Service -->> UseCase: MySQLError{Number: 1213}

        alt attempt < maxAttempts
            Note over UseCase: Deadlock detected, retrying
            UseCase ->> Logger: WARN "deadlock detected, retrying"
            Logger -->> UseCase: logged

            Note over UseCase: Calculate backoff + jitter
            Note right of UseCase
                backoffs = [0ms, 100ms, 200ms]
                jitter = ±20% of backoff
                sleep(backoff + jitter)
            end note

            UseCase ->> UseCase: time.Sleep(duration)
            Note over UseCase: Continue to next attempt
        else attempt == maxAttempts
            Note over UseCase: Last attempt failed with deadlock
            UseCase ->> UseCase: break loop
        end
    else Success
        Service -->> UseCase: ReservationResult
        UseCase -->> Client: result
        Note over UseCase: Return result immediately
    else Other error (non-deadlock)
        Service -->> UseCase: Error (validation, DB constraint, etc)
        UseCase -->> Client: error
        Note over UseCase: Return error immediately (no retry)
    end
end

Note over UseCase: After loop (if deadlock on last attempt)
UseCase -->> Client: DeadlockError("max retries exceeded")

Note right
    Jitter Calculation:
    ±20% means: random value in [0.8, 1.2]
    jitter = backoff * (0.8 + rand.Float64()*0.4)

    Prevents "thundering herd" when
    multiple transactions retry simultaneously
end note

@enduml
