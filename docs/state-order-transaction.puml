@startuml Order State & Transaction States

' Order States
state "Order\nPENDING" as ORDER_PENDING
state "Order\nCREATED" as ORDER_CREATED
state "Order\nCANCELED" as ORDER_CANCELED

ORDER_PENDING --> ORDER_CREATED: ReserveItems\n(success/partial)
ORDER_PENDING --> ORDER_PENDING: ReserveItems\n(all_failed)

' Transaction States
state "TX Start\n(BEGIN TRANSACTION)" as TX_BEGIN
state "TX Processing\nItems" as TX_PROCESS
state "TX Commit" as TX_COMMIT
state "TX Rollback" as TX_ROLLBACK

TX_BEGIN --> TX_PROCESS: Isolation: REPEATABLE_READ

TX_PROCESS --> TX_COMMIT: All items processed\nresults accumulated
TX_PROCESS --> TX_ROLLBACK: DB Error\n(unexpected)

TX_COMMIT --> ORDER_CREATED: Update Order status\n& totalPrice\nCommit success

TX_ROLLBACK --> ORDER_PENDING: Rollback\nNo changes persisted

' Reserve Result States
state "ALL_SUCCESS" as RESULT_ALL_SUCCESS
state "PARTIAL" as RESULT_PARTIAL
state "ALL_FAILED" as RESULT_ALL_FAILED

TX_COMMIT --> RESULT_ALL_SUCCESS: successes > 0\nfailures == 0
TX_COMMIT --> RESULT_PARTIAL: successes > 0\nfailures > 0
TX_ROLLBACK --> RESULT_ALL_FAILED: No items reserved\nAll fail scenarios

note right of TX_BEGIN
    context.WithTimeout(5s)
    sql.LevelRepeatableRead
    Prevents phantom reads
    Prevents dirty reads
end note

note right of TX_PROCESS
    For each item (sorted by productID ASC):
    - Lock row (SELECT FOR UPDATE)
    - Validate stock
    - Update reserved_stock
    - Create OrderItem
end note

note right of TX_COMMIT
    Only if len(successes) > 0:
    1. UpdateStatus(CREATED)
    2. UpdateTotalPrice(sum)
    3. Commit transaction

    Otherwise: defer Rollback()
end note

note right of RESULT_ALL_FAILED
    When all items fail:
    - Transaction rolled back
    - Order remains PENDING
    - No partial state
end note

@enduml
